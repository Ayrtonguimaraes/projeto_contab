"""
M√≥dulo de An√°lise Financeira Profissional
Projetado para an√°lise de indicadores cont√°beis e financeiros
"""

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
import numpy as np

class FinancialAnalyzer:
    def __init__(self, df):
        """
        Inicializa o analisador financeiro com os dados
        """
        self.df = df
        self.prepare_data()
    
    def prepare_data(self):
        """
        Prepara e limpa os dados para an√°lise
        """
        print("Iniciando prepara√ß√£o dos dados...")
        print(f"Dados originais - Shape: {self.df.shape}")
        print(f"Colunas: {self.df.columns.tolist()}")
        
        # Converter valores num√©ricos brasileiros (1.234.567,89) para formato padr√£o
        numeric_columns = self.df.columns[:-1]  # Todas exceto 'Ano'
        
        for col in numeric_columns:
            print(f"Processando coluna: {col}")
            print(f"Tipo atual: {self.df[col].dtype}")
            print(f"Amostra de valores: {self.df[col].head(3).tolist()}")
            
            if self.df[col].dtype == 'object':
                try:
                    # Tratar formato brasileiro: remover pontos (separador de milhares) e trocar v√≠rgula por ponto
                    self.df[col] = (self.df[col].astype(str)
                                   .str.strip()  # Remove espa√ßos em branco
                                   .str.replace('.', '', regex=False)  # Remove pontos (separador de milhares)
                                   .str.replace(',', '.', regex=False)  # Troca v√≠rgula por ponto (decimal)
                                   .replace(['', 'nan', 'NaN', 'None'], '0')  # Substitui valores vazios por 0
                                   .astype(float))
                    print(f"‚úÖ Coluna {col} convertida com sucesso")
                except (ValueError, TypeError) as e:
                    print(f"‚ùå Erro ao converter coluna {col}: {e}")
                    # Se falhar, tentar convers√£o direta
                    self.df[col] = pd.to_numeric(self.df[col], errors='coerce').fillna(0)
            else:
                # Se j√° √© num√©rico, garantir que √© float
                self.df[col] = pd.to_numeric(self.df[col], errors='coerce').fillna(0)
        
        # Garantir que Ano seja inteiro
        try:
            self.df['Ano'] = self.df['Ano'].astype(int)
            print(f"‚úÖ Coluna 'Ano' convertida para int")
        except:
            # Se falhar, tentar limpeza primeiro
            self.df['Ano'] = pd.to_numeric(self.df['Ano'], errors='coerce').fillna(2024).astype(int)
            print(f"‚ö†Ô∏è Coluna 'Ano' convertida com fallback")
        
        # Ordenar por ano
        self.df = self.df.sort_values('Ano')
        
        print("‚úÖ Prepara√ß√£o dos dados conclu√≠da!")
        print(f"Dados finais - Shape: {self.df.shape}")
        print(f"Tipos de dados:")
        for col in self.df.columns:
            print(f"  {col}: {self.df[col].dtype}")
        print("="*50)
    
    def get_kpis_principais(self):
        """
        Calcula e retorna os KPIs principais
        """
        ano_atual = self.df['Ano'].max()
        ano_anterior = self.df['Ano'].min()
        
        dados_atual = self.df[self.df['Ano'] == ano_atual].iloc[0]
        dados_anterior = self.df[self.df['Ano'] == ano_anterior].iloc[0]
        
        def calcular_variacao(atual, anterior):
            if anterior != 0:
                return ((atual - anterior) / anterior) * 100
            return 0
        
        kpis = {
            'receita_liquida': {
                'atual': dados_atual['Receita L√≠quida'],
                'anterior': dados_anterior['Receita L√≠quida'],
                'variacao': calcular_variacao(dados_atual['Receita L√≠quida'], dados_anterior['Receita L√≠quida'])
            },
            'lucro_liquido': {
                'atual': dados_atual['Lucro L√≠quido'],
                'anterior': dados_anterior['Lucro L√≠quido'],
                'variacao': calcular_variacao(dados_atual['Lucro L√≠quido'], dados_anterior['Lucro L√≠quido'])
            },
            'roe': {
                'atual': dados_atual['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '],
                'anterior': dados_anterior['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '],
                'variacao': calcular_variacao(dados_atual['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '], 
                                           dados_anterior['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '])
            },
            'roa': {
                'atual': dados_atual['Rentabilidade do Ativo (ROA ou ROI)'],
                'anterior': dados_anterior['Rentabilidade do Ativo (ROA ou ROI)'],
                'variacao': calcular_variacao(dados_atual['Rentabilidade do Ativo (ROA ou ROI)'], 
                                           dados_anterior['Rentabilidade do Ativo (ROA ou ROI)'])
            },
            'margem_liquida': {
                'atual': dados_atual['Margem L√≠quida (ML)'],
                'anterior': dados_anterior['Margem L√≠quida (ML)'],
                'variacao': calcular_variacao(dados_atual['Margem L√≠quida (ML)'], 
                                           dados_anterior['Margem L√≠quida (ML)'])
            },
            'liquidez_corrente': {
                'atual': dados_atual['Liquidez Corrente (LC) '],
                'anterior': dados_anterior['Liquidez Corrente (LC) '],
                'variacao': calcular_variacao(dados_atual['Liquidez Corrente (LC) '], 
                                           dados_anterior['Liquidez Corrente (LC) '])
            }
        }
        
        return kpis
    
    def create_rentabilidade_chart(self):
        """
        Gr√°fico de An√°lise de Rentabilidade (ROA, ROE, Margem L√≠quida)
        """
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('ROE - Rentabilidade do Patrim√¥nio', 'ROA - Rentabilidade do Ativo', 
                          'Margem L√≠quida', 'Comparativo de Rentabilidade'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        anos = self.df['Ano'].tolist()
        roe = self.df['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '].tolist()
        roa = self.df['Rentabilidade do Ativo (ROA ou ROI)'].tolist()
        margem = self.df['Margem L√≠quida (ML)'].tolist()
        
        # ROE
        fig.add_trace(
            go.Scatter(x=anos, y=roe, mode='lines+markers', name='ROE', 
                      line=dict(color='#1f77b4', width=3), marker=dict(size=10)),
            row=1, col=1
        )
        
        # ROA
        fig.add_trace(
            go.Scatter(x=anos, y=roa, mode='lines+markers', name='ROA',
                      line=dict(color='#ff7f0e', width=3), marker=dict(size=10)),
            row=1, col=2
        )
        
        # Margem L√≠quida
        fig.add_trace(
            go.Scatter(x=anos, y=margem, mode='lines+markers', name='Margem L√≠quida',
                      line=dict(color='#2ca02c', width=3), marker=dict(size=10)),
            row=2, col=1
        )
        
        # Comparativo
        fig.add_trace(
            go.Scatter(x=anos, y=roe, mode='lines+markers', name='ROE',
                      line=dict(color='#1f77b4', width=2)),
            row=2, col=2
        )
        fig.add_trace(
            go.Scatter(x=anos, y=roa, mode='lines+markers', name='ROA',
                      line=dict(color='#ff7f0e', width=2)),
            row=2, col=2
        )
        fig.add_trace(
            go.Scatter(x=anos, y=margem, mode='lines+markers', name='Margem L√≠quida',
                      line=dict(color='#2ca02c', width=2)),
            row=2, col=2
        )
        
        fig.update_layout(
            title="üìà An√°lise de Rentabilidade",
            height=600,
            showlegend=False
        )
        
        return fig
    
    def create_liquidez_radar(self):
        """
        Gr√°fico Radar dos Indicadores de Liquidez
        """
        anos = self.df['Ano'].tolist()
        
        # Indicadores de liquidez
        indicators = ['Liquidez Geral (LG)', 'Liquidez Corrente (LC) ', 
                     'Liquidez Seca (LS)', 'Liquidez Imediata (LI)']
        
        fig = go.Figure()
        
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728']
        
        for i, ano in enumerate(anos):
            valores = []
            for indicator in indicators:
                valores.append(self.df[self.df['Ano'] == ano][indicator].iloc[0])
            
            # Adicionar o primeiro valor no final para fechar o radar
            valores.append(valores[0])
            labels = [ind.replace(' (', '<br>(').replace(') ', ')') for ind in indicators]
            labels.append(labels[0])
            
            fig.add_trace(go.Scatterpolar(
                r=valores,
                theta=labels,
                fill='toself',
                name=f'Ano {ano}',
                line=dict(color=colors[i], width=3),
                marker=dict(size=8)
            ))
        
        fig.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[0, max([self.df[ind].max() for ind in indicators]) * 1.1]
                )
            ),
            showlegend=True,
            title="üõ°Ô∏è Radar de Indicadores de Liquidez",
            height=500
        )
        
        return fig
    
    def create_estrutura_capital(self):
        """
        An√°lise da Estrutura de Capital
        """
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Endividamento Geral', 'Composi√ß√£o do Endividamento', 
                          'Participa√ß√£o de Terceiros', 'Evolu√ß√£o da Estrutura'),
            specs=[[{"type": "bar"}, {"type": "bar"}],
                   [{"type": "bar"}, {"type": "scatter"}]]
        )
        
        anos = self.df['Ano'].tolist()
        
        # Endividamento Geral
        eg = self.df['Endividamento Geral (EG)'].tolist()
        fig.add_trace(
            go.Bar(x=anos, y=eg, name='Endividamento Geral', 
                   marker_color='#ff6b6b'),
            row=1, col=1
        )
        
        # Composi√ß√£o do Endividamento
        ce = self.df['Composi√ß√£o do Endividamento (CE)'].tolist()
        fig.add_trace(
            go.Bar(x=anos, y=ce, name='Composi√ß√£o Endividamento',
                   marker_color='#4ecdc4'),
            row=1, col=2
        )
        
        # Participa√ß√£o de Capitais de Terceiros
        pct = self.df['Participa√ß√£o de Capitais de Terceiros (PCT) ‚Äì Grau de Endividamento'].tolist()
        fig.add_trace(
            go.Bar(x=anos, y=pct, name='PCT',
                   marker_color='#45b7d1'),
            row=2, col=1
        )
        
        # Evolu√ß√£o conjunta
        fig.add_trace(
            go.Scatter(x=anos, y=eg, mode='lines+markers', name='Endividamento Geral',
                      line=dict(color='#ff6b6b', width=3)),
            row=2, col=2
        )
        fig.add_trace(
            go.Scatter(x=anos, y=ce, mode='lines+markers', name='Composi√ß√£o',
                      line=dict(color='#4ecdc4', width=3)),
            row=2, col=2
        )
        
        fig.update_layout(
            title="üè¶ An√°lise da Estrutura de Capital",
            height=600,
            showlegend=False
        )
        
        return fig
    
    def create_evolucao_patrimonial(self):
        """
        Gr√°fico de Evolu√ß√£o Patrimonial
        """
        fig = go.Figure()
        
        anos = self.df['Ano'].tolist()
        ativo_total = self.df['Ativo Total'].tolist()
        patrimonio_liquido = self.df['Patrim√¥nio L√≠quido'].tolist()
        passivo_circulante = self.df['Passivo Circulante'].tolist()
        passivo_nao_circulante = self.df['Passivo N√£o Circulante'].tolist()
        
        fig.add_trace(go.Scatter(
            x=anos, y=ativo_total,
            mode='lines+markers',
            name='Ativo Total',
            line=dict(color='#1f77b4', width=4),
            marker=dict(size=12)
        ))
        
        fig.add_trace(go.Scatter(
            x=anos, y=patrimonio_liquido,
            mode='lines+markers',
            name='Patrim√¥nio L√≠quido',
            line=dict(color='#2ca02c', width=4),
            marker=dict(size=12)
        ))
        
        fig.add_trace(go.Scatter(
            x=anos, y=passivo_circulante,
            mode='lines+markers',
            name='Passivo Circulante',
            line=dict(color='#ff7f0e', width=3),
            marker=dict(size=10)
        ))
        
        fig.add_trace(go.Scatter(
            x=anos, y=passivo_nao_circulante,
            mode='lines+markers',
            name='Passivo N√£o Circulante',
            line=dict(color='#d62728', width=3),
            marker=dict(size=10)
        ))
        
        fig.update_layout(
            title="üí∞ Evolu√ß√£o Patrimonial",
            xaxis_title="Ano",
            yaxis_title="Valor (R$)",
            height=500,
            hovermode='x unified'
        )
        
        return fig
    
    def create_analise_dupont(self):
        """
        An√°lise DuPont - Decomposi√ß√£o do ROA
        """
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Margem L√≠quida vs Giro do Ativo', 'ROA vs ROE', 
                          'Multiplicador de Alavancagem', 'Decomposi√ß√£o DuPont'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        anos = self.df['Ano'].tolist()
        margem = self.df['Margem L√≠quida (ML)'].tolist()
        giro = self.df['Giro do Ativo (GA)'].tolist()
        roa = self.df['Rentabilidade do Ativo (ROA ou ROI)'].tolist()
        roe = self.df['Rentabilidade do Patrim√¥nio L√≠quido (ROE) '].tolist()
        maf = self.df['Multiplicador de Alavancagem Financeira (MAF)'].tolist()
        
        # Margem vs Giro
        fig.add_trace(
            go.Scatter(x=margem, y=giro, mode='markers+text', 
                      text=[str(ano) for ano in anos],
                      textposition="middle right",
                      marker=dict(size=15, color=anos, colorscale='viridis'),
                      name='Margem vs Giro'),
            row=1, col=1
        )
        
        # ROA vs ROE
        fig.add_trace(
            go.Scatter(x=roa, y=roe, mode='markers+text',
                      text=[str(ano) for ano in anos],
                      textposition="middle right",
                      marker=dict(size=15, color=anos, colorscale='plasma'),
                      name='ROA vs ROE'),
            row=1, col=2
        )
        
        # Multiplicador de Alavancagem
        fig.add_trace(
            go.Bar(x=anos, y=maf, name='Multiplicador Alavancagem',
                   marker_color='#ff9999'),
            row=2, col=1
        )
        
        # Decomposi√ß√£o DuPont (ROA = Margem √ó Giro)
        roa_calculado = [m * g for m, g in zip(margem, giro)]
        fig.add_trace(
            go.Scatter(x=anos, y=roa, mode='lines+markers', name='ROA Real',
                      line=dict(color='#1f77b4', width=3)),
            row=2, col=2
        )
        fig.add_trace(
            go.Scatter(x=anos, y=roa_calculado, mode='lines+markers', name='ROA Calculado',
                      line=dict(color='#ff7f0e', width=3, dash='dash')),
            row=2, col=2
        )
        
        fig.update_layout(
            title="üîç An√°lise DuPont - Decomposi√ß√£o da Rentabilidade",
            height=700,
            showlegend=False
        )
        
        return fig
    
    def create_ciclo_financeiro(self):
        """
        An√°lise do Ciclo Operacional e Financeiro
        """
        fig = make_subplots(
            rows=1, cols=2,
            subplot_titles=('Prazos M√©dios (dias)', 'Ciclo Operacional vs Financeiro')
        )
        
        anos = self.df['Ano'].tolist()
        pmre = self.df['Prazo M√©dio de Renova√ß√£o dos Estoques (PMRE) '].tolist()
        pmrv = self.df['Prazo M√©dio de Recebimento das Vendas (PMRV) '].tolist()
        pmpc = self.df['Prazo M√©dio de Pagamento das Compras (PMPC) '].tolist()
        ciclo = self.df['Ciclo Operacional e Ciclo Financeiro'].tolist()
        
        # Prazos m√©dios
        fig.add_trace(
            go.Bar(x=anos, y=pmre, name='PMRE - Estoques', marker_color='#ff9999'),
            row=1, col=1
        )
        fig.add_trace(
            go.Bar(x=anos, y=pmrv, name='PMRV - Recebimento', marker_color='#66b3ff'),
            row=1, col=1
        )
        fig.add_trace(
            go.Bar(x=anos, y=pmpc, name='PMPC - Pagamento', marker_color='#99ff99'),
            row=1, col=1
        )
        
        # Ciclo Financeiro
        ciclo_operacional = [pmre_val + pmrv_val for pmre_val, pmrv_val in zip(pmre, pmrv)]
        
        fig.add_trace(
            go.Scatter(x=anos, y=ciclo_operacional, mode='lines+markers', 
                      name='Ciclo Operacional', line=dict(color='#1f77b4', width=4)),
            row=1, col=2
        )
        fig.add_trace(
            go.Scatter(x=anos, y=ciclo, mode='lines+markers',
                      name='Ciclo Financeiro', line=dict(color='#ff7f0e', width=4)),
            row=1, col=2
        )
        
        fig.update_layout(
            title="‚è±Ô∏è An√°lise do Ciclo Operacional e Financeiro",
            height=500
        )
        
        return fig
    
    def create_heatmap_indicadores(self):
        """
        Heatmap de todos os indicadores para an√°lise comparativa
        """
        # Selecionar indicadores principais para o heatmap
        indicadores_selecionados = [
            'Liquidez Geral (LG)', 'Liquidez Corrente (LC) ', 'Liquidez Seca (LS)',
            'Endividamento Geral (EG)', 'Margem L√≠quida (ML)', 
            'Rentabilidade do Ativo (ROA ou ROI)', 'Rentabilidade do Patrim√¥nio L√≠quido (ROE) ',
            'Giro do Ativo (GA)'
        ]
        
        # Preparar dados para heatmap
        heatmap_data = []
        anos = self.df['Ano'].tolist()
        
        for indicador in indicadores_selecionados:
            valores = self.df[indicador].tolist()
            heatmap_data.append(valores)
        
        # Normalizar os dados para melhor visualiza√ß√£o
        heatmap_data_norm = []
        for row in heatmap_data:
            if max(row) != min(row):
                normalized = [(x - min(row)) / (max(row) - min(row)) for x in row]
            else:
                normalized = [0.5] * len(row)
            heatmap_data_norm.append(normalized)
        
        fig = go.Figure(data=go.Heatmap(
            z=heatmap_data_norm,
            x=[f'Ano {ano}' for ano in anos],
            y=[ind.replace(' (', '<br>(') for ind in indicadores_selecionados],
            colorscale='RdYlBu_r',
            showscale=True
        ))
        
        fig.update_layout(
            title="üå°Ô∏è Heatmap de Indicadores Financeiros (Normalizado)",
            height=600
        )
        
        return fig
    
    def get_data_for_ai(self):
        """
        Prepara dados estruturados para an√°lise da IA
        """
        return {
            'dados_brutos': self.df.to_dict('records'),
            'kpis': self.get_kpis_principais(),
            'anos_analisados': self.df['Ano'].tolist(),
            'total_indicadores': len(self.df.columns) - 1,
            'indicadores_principais': {
                'rentabilidade': ['Rentabilidade do Ativo (ROA ou ROI)', 'Rentabilidade do Patrim√¥nio L√≠quido (ROE) ', 'Margem L√≠quida (ML)'],
                'liquidez': ['Liquidez Geral (LG)', 'Liquidez Corrente (LC) ', 'Liquidez Seca (LS)', 'Liquidez Imediata (LI)'],
                'endividamento': ['Endividamento Geral (EG)', 'Participa√ß√£o de Capitais de Terceiros (PCT) ‚Äì Grau de Endividamento', 'Composi√ß√£o do Endividamento (CE)'],
                'eficiencia': ['Giro do Ativo (GA)', 'Prazo M√©dio de Renova√ß√£o dos Estoques (PMRE) ', 'Prazo M√©dio de Recebimento das Vendas (PMRV) ']
            }
        }
    def get_indicadores_tabela(self):
        """Gera tabela consolidada de indicadores com varia√ß√µes ano a ano.
        Retorna DataFrame com colunas: Indicador, Categoria, Ano Atual, Ano Anterior, Varia√ß√£o Abs, Varia√ß√£o %.
        Se menos de 2 anos, retorna DataFrame vazio.
        """
        import pandas as pd
        if 'Ano' not in self.df.columns:
            return pd.DataFrame()
        anos = sorted(self.df['Ano'].unique())
        if len(anos) < 2:
            return pd.DataFrame()
        ano_ant, ano_atual = anos[-2], anos[-1]
        row_atual = self.df[self.df['Ano'] == ano_atual].iloc[0]
        row_ant = self.df[self.df['Ano'] == ano_ant].iloc[0]
        categorias = {
            'Liquidez Geral (LG)': 'Liquidez', 'Liquidez Corrente (LC) ': 'Liquidez', 'Liquidez Seca (LS)': 'Liquidez', 'Liquidez Imediata (LI)': 'Liquidez',
            'Rentabilidade do Patrim√¥nio L√≠quido (ROE) ': 'Rentabilidade', 'Rentabilidade do Ativo (ROA ou ROI)': 'Rentabilidade', 'Margem L√≠quida (ML)': 'Rentabilidade', 'Giro do Ativo (GA)': 'Rentabilidade', 'Multiplicador de Alavancagem Financeira (MAF)': 'Rentabilidade', 'An√°lise do ROI (M√©todo DuPont) ': 'Rentabilidade',
            'Endividamento Geral (EG)': 'Estrutura/Endividamento', 'Participa√ß√£o de Capitais de Terceiros (PCT) ‚Äì Grau de Endividamento': 'Estrutura/Endividamento', 'Composi√ß√£o do Endividamento (CE)': 'Estrutura/Endividamento', 'Grau de Imobiliza√ß√£o do Patrim√¥nio L√≠quido (ImPL)': 'Estrutura/Endividamento', 'Grau de Imobiliza√ß√£o dos Recursos n√£o Correntes (IRNC) ': 'Estrutura/Endividamento',
            'Prazo M√©dio de Renova√ß√£o dos Estoques (PMRE) ': 'Ciclo Operacional', 'Prazo M√©dio de Recebimento das Vendas (PMRV) ': 'Ciclo Operacional', 'Prazo M√©dio de Pagamento das Compras (PMPC) ': 'Ciclo Operacional', 'Ciclo Operacional e Ciclo Financeiro': 'Ciclo Operacional',
            'Alavancagem Financeira (GAF)': 'Alavancagem', 'Alavancagem Operacional (GAO)': 'Alavancagem', 'Alavancagem Total (GAT) - C√°lculo Poss√≠vel': 'Alavancagem',
            'Ativo Total': 'Performance / Base', 'Imobilizado': 'Performance / Base', 'Passivo Circulante': 'Performance / Base', 'Passivo N√£o Circulante': 'Performance / Base', 'Patrim√¥nio L√≠quido': 'Performance / Base', 'Receita L√≠quida': 'Performance / Base', 'Lucro L√≠quido': 'Performance / Base', 'Lucro Operacional': 'Performance / Base', 'Lucro Antes dos Impostos': 'Performance / Base', 'Custo dos Produtos Vendidos (CPV)': 'Performance / Base', 'Caixa e Equivalentes de Caixa': 'Performance / Base', 'Estoques': 'Performance / Base', 'Contas a Receber (Circulante)': 'Performance / Base', 'Fornecedores': 'Performance / Base', 'Realiz√°vel a Longo Prazo': 'Performance / Base'
        }
        registros = []
        for col in self.df.columns:
            if col == 'Ano':
                continue
            try:
                v_at = float(row_atual[col])
                v_an = float(row_ant[col])
                var_abs = v_at - v_an
                var_pct = (var_abs / v_an * 100) if v_an not in (0, None) else None
                registros.append({
                    'Indicador': col,
                    'Categoria': categorias.get(col, 'Outros'),
                    'Ano Anterior': v_an,
                    'Ano Atual': v_at,
                    'Varia√ß√£o Abs': var_abs,
                    'Varia√ß√£o %': var_pct
                })
            except Exception:
                continue
        df_out = pd.DataFrame(registros)
        if df_out.empty:
            return df_out
        # Ordena√ß√£o: categoria depois indicador
        return df_out.sort_values(['Categoria', 'Indicador']).reset_index(drop=True)
    # ---- LEGACY WRAPPERS (Backward Compatibility) ----
    # Alguns trechos antigos/fallback ainda chamam m√©todos removidos. 
    # Mantemos aliases para evitar quebras at√© completa remo√ß√£o do c√≥digo legado.
    def create_liquidez_chart(self):
        return self.create_liquidez_radar()
    def create_endividamento_chart(self):
        return self.create_estrutura_capital()
    def create_ciclo_chart(self):
        return self.create_ciclo_financeiro()
    def create_heatmap_geral(self):
        return self.create_heatmap_indicadores()
    
    # ---- M√âTODOS MELHORADOS PARA MINIATURAS ----
    # Vers√µes simplificadas dos gr√°ficos melhorados do dashboard executivo
    
    def create_rentabilidade_melhorado(self):
        """Waterfall DuPont simplificado para miniatura"""
        df = self.df.sort_values('Ano')
        if len(df) < 2:
            return self.create_rentabilidade_chart()  # Fallback
            
        required = ['Margem L√≠quida (ML)','Giro do Ativo (GA)','Multiplicador de Alavancagem Financeira (MAF)','Rentabilidade do Patrim√¥nio L√≠quido (ROE) ']
        if not all(c in df.columns for c in required):
            return self.create_rentabilidade_chart()  # Fallback
            
        prev, cur = df.iloc[-2], df.iloc[-1]
        ano_prev, ano_cur = int(prev['Ano']), int(cur['Ano'])
        
        ml1, ml2 = prev[required[0]], cur[required[0]]
        ga1, ga2 = prev[required[1]], cur[required[1]]
        maf1, maf2 = prev[required[2]], cur[required[2]]
        roe1, roe2 = prev[required[3]], cur[required[3]]
        
        # Aproxima√ß√£o simples da contribui√ß√£o
        delta_roe_pp = (roe2 - roe1) * 100
        contrib_ml = (ml2 - ml1) / ml1 * 100 if ml1 != 0 else 0
        contrib_ga = (ga2 - ga1) / ga1 * 100 if ga1 != 0 else 0  
        contrib_maf = (maf2 - maf1) / maf1 * 100 if maf1 != 0 else 0
        
        total_contrib = abs(contrib_ml) + abs(contrib_ga) + abs(contrib_maf) or 1
        values = [
            delta_roe_pp * (abs(contrib_ml)/total_contrib) * (1 if contrib_ml >= 0 else -1),
            delta_roe_pp * (abs(contrib_ga)/total_contrib) * (1 if contrib_ga >= 0 else -1),
            delta_roe_pp * (abs(contrib_maf)/total_contrib) * (1 if contrib_maf >= 0 else -1),
            delta_roe_pp
        ]
        
        fig = go.Figure(go.Waterfall(
            x=['Margem', 'Giro', 'MAF', 'Œî ROE (pp)'],
            measure=['relative', 'relative', 'relative', 'total'],
            y=values,
            connector={'line': {'color': 'rgba(120,120,120,0.4)'}}
        ))
        fig.update_layout(title=f"DuPont: Contribui√ß√£o Œî ROE ({ano_prev}‚Üí{ano_cur})")
        return fig
    
    def create_liquidez_melhorado(self):
        """Slope charts de liquidez para miniatura"""
        df = self.df.sort_values('Ano')
        if len(df) < 2:
            return self.create_liquidez_radar()  # Fallback
            
        prev, cur = df.iloc[-2], df.iloc[-1]
        ano_prev, ano_cur = int(prev['Ano']), int(cur['Ano'])
        
        if 'Liquidez Corrente (LC) ' not in df.columns or 'Liquidez Imediata (LI)' not in df.columns:
            return self.create_liquidez_radar()  # Fallback
            
        lc_prev, lc_cur = prev['Liquidez Corrente (LC) '], cur['Liquidez Corrente (LC) ']
        li_prev, li_cur = prev['Liquidez Imediata (LI)'], cur['Liquidez Imediata (LI)']
        
        fig = go.Figure()
        # LC
        fig.add_trace(go.Scatter(
            x=[ano_prev, ano_cur], y=[lc_prev, lc_cur],
            mode='lines+markers+text', name='LC',
            text=[f"{lc_prev:.2f}", f"{lc_cur:.2f}"],
            line=dict(color='#3498db', width=3)
        ))
        # LI  
        fig.add_trace(go.Scatter(
            x=[ano_prev, ano_cur], y=[li_prev, li_cur],
            mode='lines+markers+text', name='LI',
            text=[f"{li_prev:.2f}", f"{li_cur:.2f}"],
            line=dict(color='#e74c3c', width=3)
        ))
        fig.add_hline(y=1.0, line_dash="dash", line_color="red", opacity=0.5)
        fig.update_layout(title="Evolu√ß√£o Liquidez (LC/LI)")
        return fig
    
    def create_endividamento_melhorado(self):
        """Barras comparativas de endividamento para miniatura"""
        df = self.df.sort_values('Ano')
        if len(df) < 2:
            return self.create_estrutura_capital()  # Fallback
            
        required = ['Passivo Circulante', 'Passivo N√£o Circulante']
        if not all(c in df.columns for c in required):
            return self.create_estrutura_capital()  # Fallback
            
        prev, cur = df.iloc[-2], df.iloc[-1]
        ano_prev, ano_cur = int(prev['Ano']), int(cur['Ano'])
        
        pc_prev, pc_cur = prev['Passivo Circulante'], cur['Passivo Circulante']
        pnc_prev, pnc_cur = prev['Passivo N√£o Circulante'], cur['Passivo N√£o Circulante']
        
        fig = go.Figure()
        fig.add_bar(name='Curto Prazo', x=[str(ano_prev), str(ano_cur)], y=[pc_prev, pc_cur], marker_color='#e74c3c')
        fig.add_bar(name='Longo Prazo', x=[str(ano_prev), str(ano_cur)], y=[pnc_prev, pnc_cur], marker_color='#3498db')
        fig.update_layout(barmode='stack', title='Evolu√ß√£o Passivos (Absoluto)')
        return fig
    
    def create_ciclo_melhorado(self):
        """Slope chart do ciclo + barras componentes para miniatura"""  
        df = self.df.sort_values('Ano')
        if len(df) < 2:
            return self.create_ciclo_financeiro()  # Fallback
            
        required = ['Prazo M√©dio de Renova√ß√£o dos Estoques (PMRE) ','Prazo M√©dio de Recebimento das Vendas (PMRV) ','Prazo M√©dio de Pagamento das Compras (PMPC) ','Ciclo Operacional e Ciclo Financeiro']
        if not all(c in df.columns for c in required):
            return self.create_ciclo_financeiro()  # Fallback
            
        prev, cur = df.iloc[-2], df.iloc[-1]
        ano_prev, ano_cur = int(prev['Ano']), int(cur['Ano'])
        
        ciclo_prev = prev['Ciclo Operacional e Ciclo Financeiro']
        ciclo_cur = cur['Ciclo Operacional e Ciclo Financeiro']
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=[ano_prev, ano_cur], y=[ciclo_prev, ciclo_cur],
            mode='lines+markers+text',
            text=[f"{ciclo_prev:.0f}", f"{ciclo_cur:.0f}"],
            line=dict(color='#e74c3c', width=4),
            marker=dict(size=12),
            name='Ciclo Financeiro'
        ))
        fig.update_layout(title='Evolu√ß√£o Ciclo Financeiro (dias)', yaxis_title='Dias')
        return fig
